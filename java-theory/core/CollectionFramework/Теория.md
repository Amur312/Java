### **Что такое коллекции**

Коллекции — это наборы однородных элементов. Например, страницы в книге, яблоки в корзине или люди в очереди.

Инструменты для работы с такими структурами в Java содержатся в **Java Collections Framework**. Фреймворк состоит из
интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования.

![img.png](img/img.png)

На схеме видно, что существует два основных интерфейса, от которых реализуются остальные классы и интерфейсы коллекций.

1. **Collection** – обычная коллекция, которая содержит набор отдельных элементов (объектов). В этой коллекции есть
   основные
   методы для работы с элементами: вставка (**add**, **addAll**), удаление (**remove**, **removeAll**, **clear**),
   поиск (**contains**,
   **containsAll**), проверка на пустоту коллекции (**isEmpty**) и размер (**size**).

2. **Map** — коллекция, структура которой представляет собой пары "ключ — значение". Причем в рамках одной Map каждый
   ключ
   уникален: нет двух одинаковых по значению ключей. Также эту коллекцию иногда называют словарем (dictionary). **Map
   ** —
   это отдельный интерфейс. Он не реализует интерфейс **Collection**, но входит в Java Collections Framework.

### Начнем с интерфейса Collection

Интерфейс Collection расширяет интерфейс **Iterable**, а у этого интерфейса есть единственный метод **iterator()**. Для
нас это
означает, что любая коллекция, которая наследуется от Iterable, будет уметь возвращать итератор.

**Iterator** используется для перебора элементов коллекции. Итератор предоставляет для этого три метода:

* **E next();** – Позволяет получить следующий элемент коллекции.
* **boolean hasNext();** – Возвращает true, если следующий элемент есть.
* **void remove();** – Удаляет текущий элемент.

Эти интерфейсы позволяют объектам быть целевыми для оператора "**for-each**", что упрощает итерацию по коллекциям.

```java
final List<String> names = List.of("mark", "mike", "kate");
for(
String name :names){ // цикл for-each
        System.out.

println(name);
}
```

Интерфейс **Collection** является основным интерфейсом для всех типов коллекций в Java и расширяет интерфейс Iterable.
Он
предоставляет широкий набор методов для управления элементами коллекции, включая операции добавления, удаления, поиска и
получения информации о коллекции.

1. **boolean add(E e)**: Добавляет элемент в коллекцию. Возвращает true, если коллекция изменилась после вызова метода.
2. **boolean addAll(Collection<? extends E> c)**: Добавляет все элементы из указанной коллекции в данную коллекцию.
   Возвращает true, если коллекция изменилась после вызова метода.
3. **void clear()**: Удаляет все элементы из коллекции.
4. **boolean contains(Object o)**: Возвращает true, если коллекция содержит указанный элемент.
5. **boolean containsAll(Collection<?> c)**: Возвращает true, если коллекция содержит все элементы указанной коллекции.
6. **boolean equals(Object o)**: Сравнивает указанный объект с текущей коллекцией на равенство.
7. **int hashCode()**: Возвращает хеш-код для коллекции.
8. **boolean isEmpty()**: Возвращает true, если коллекция не содержит элементов.
9. **Iterator<E> iterator()**: Возвращает итератор для перебора элементов коллекции.
10. **boolean remove(Object o)**: Удаляет указанный элемент из коллекции. Возвращает true, если коллекция содержала
    элемент
    перед удалением.
11. **boolean removeAll(Collection<?> c)**: Удаляет из коллекции все элементы, которые содержатся в указанной коллекции.
    Возвращает true, если коллекция изменилась после вызова метода.
12. **boolean retainAll(Collection<?> c)**: Удаляет из коллекции все элементы, которые не содержатся в указанной
    коллекции.
    Возвращает true, если коллекция изменилась после вызова метода.
13. **int size()**: Возвращает количество элементов в коллекции.
14. **Object[] toArray()**: Возвращает массив, содержащий все элементы коллекции.
15. **<T> T[] toArray(T[] a)**: Возвращает массив, содержащий все элементы коллекции, при этом тип массива определяется
    указанным массивом 'a'.

**Кроме того, в Java 8 были добавлены дополнительные методы для работы с коллекциями, такие как методы для стримов,
фильтрации, сортировки и преобразования элементов. Некоторые из них включают stream(), parallelStream(), removeIf(
Predicate<? super E> filter), forEach(Consumer<? super E> action) и другие.**

### Интерфейс List

Интерфейс **List** в Java Collection Framework представляет упорядоченную коллекцию (также известную как
последовательность). Интерфейс **List** расширяет **Collection** и предоставляет широкий спектр методов для манипуляций
с
элементами коллекции.

Используется для создания простых списков:

* Сохраняет последовательность элементов

* Элементы могут быть доступны по индексу

* Может содержать повторяющиеся элементы

```java
public interface List<E> extends Collection<E>
```

Помимо **Iterator** списки также могут вернуть **Listerator**, который позволяет вставку и замену элементов, а также
двунаправленный доступ.

Рассмотрим основные методы, предоставляемые интерфейсом **List**:

1. **void add(int index, object obj)** – вставляет элемент obj в позицию index. Старые элементы, начиная с позиции
   index, сдвигаются, их индексы увеличиваются на единицу.
2. **boolean addAll(int index, Collection coll)** – вставляет все элементы коллекции coll
3. **object get(int index)** – Этот метод используется для получения элемента из списка по указанному индексу.
4. **int indexOf(Object obj)** – Возвращает индекс первого вхождения указанного элемента в этом списке или -1, если этот
   список не содержит элемента.
5. **int lastindexOf(object obj)** – Возвращает индекс последнего вхождения указанного элемента в этом списке или -1,
   если этот список не содержит элемента.
6. **Object set(int index, object obj)** – Используется для замены элемента в этом списке на указанной позиции на
   указанный элемент.
7. **List subList(int from, int to)** – возвращает часть коллекции от позиции from включительно до позиции to
   исключительно.

Это основные методы, которые предоставляет интерфейс List, и которые могут быть использованы для выполнения операций
над списками, таких как добавление, удаление, получение и замена элементов.

### Класс ArrayList

**ArrayList** в Java — это динамический массив, который хранит свои элементы в массиве. Размер этого массива (емкость
**ArrayList**) автоматически увеличивается, когда мы добавляем больше элементов, чем он может вместить. Внутри, *
*ArrayList**
использует массив объектов (**Object[]**) для хранения элементов.

_Стоит так же упомянуть, что до появления Java Collection Framework существовал класс Vector, который в последствии был
включен в Java Collection. В отличии от всех реализаций колекции, Vector синхронизирован. Если потокобезопасная
реализация не требуется, рекомендуется использовать ArrayList вместо Vector._

Каждый экземпляр **ArrayList** имеет емкость (**CAPACITY**). Емкость – это размер массива, который используется для
хранения
элементов. По мере добавления элементов в **ArrayList** его емкость автоматически увеличивается. Начальный размер
capacity
равен 10. Вы можете передать свое значение capacity используя конструктор **public ArrayList(int initialCapacity)**.

![img.png](img.png)

Когда элементы добавляются в **ArrayList** и его емкость становится недостаточной, его емкость увеличивается. Новая
емкость
рассчитывается как **старая емкость * 1.5 + 1**. То есть, если у нас было место для 10 элементов, теперь будет 16.
Внутренний массив создается заново с новой емкостью и старые элементы копируются в новый массив. **Это довольно
затратная
операция, поэтому если изначально известно, что **ArrayList** будет хранить много элементов, рекомендуется задавать
достаточно большую начальную емкость.**

Удаление элементов из **ArrayList** также может быть затратной операцией, особенно если удаляется элемент из середины
списка. При удалении элемента, все элементы, следующие за ним, сдвигаются на одну позицию назад, что требует копирования
данных.

При этом размер внутреннего массива автоматически не уменьшается, поэтому если из массива часто удаляются элементы, и
при этом не добавляется новых, имеет смысл использовать метод **trimToSize**();. Этот метод есть только у ArrayList и
отсутсвует у List.

ArrayList не синхронизирован, то есть не является потокобезопасным. Если несколько потоков изменяют ArrayList
одновременно, его состояние может стать непредсказуемым.

Выводы:

* Использует внутри простой массив;
* Автоматически увеличивается, **но не уменьшается**;
* **Не синхронизирован**;
* Быстрый доступ к элементам по индексу за время O(1);
* Быстрая вставка и удаление элементов с конца за константное время O(1)
* Доступ к элементам по значению за линейное время O(n);
* **Медленная вставка и удаление элементов из середины**
* Позволяет хранить любые значения в том числе и null;

```java
public class ArrayList<E>
        extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, Serializable
```

**Конструкторы ArrayList:**

```java
ArrayList();

ArrayList(100);                             // задаем емкость capacity

ArrayList<>(collection);
```

```java
list.add(" world!");                        // добавить в конец списка
list.

add(0,"Hello");                        // добавить по индексу

list.

size();                                // количество элементов

list.

remove("Hello");                        // удалить по значению
list.

remove(1);                                // удалить по индексу
```

### Класс LinkedList

**LinkedList** реализует интерфейс **List** и **Deque**. Он представляет собой двусвязный список, что означает, что
каждый элемент
списка (обычно называемый "узел") содержит ссылку как на следующий, так и на предыдущий узел в списке.

![img_1.png](img_1.png)

Класс **LinkedList** содержит три основных поля:

* **Node<E> first** – ссылка на первый элемент списка
* **Node<E> last** – ссылка на второй элемент списка
* **int size** – размер коллекции

Каждый узел (**Node**) в **LinkedList** хранит два элемента: данные и ссылку на следующий и предыдущий узел.

![img_2.png](img_2.png)

**Добавление элементов в конец списка:**

* Создание нового узла (Node).
* Установка объекта в поле item этого узла.
* Добавление ссылки узла в конец списка.
* Установку ссылок на соседние узлы.

**Добавление эелмента в середину списка**

* Осуществляется проверка значения позиции добавления. Если позиция отрицательная, или больше размера списка, то будет
  сгенирировано исключение IndexOutOfBoundsException.
* Если позиция добавления равна размеру коллекции, то осуществляются действия описанные в "Добавление элемента в
  середину списка"
* Если же позиция не равна размеру списка, то осуществляется вставка перед элементом, который до этой вставки имеет
  заданный индекс.
* Для начала с помощью метода node(index) определяется узел, находящийся в данный момент под индексом, под который нам
  необходимо вставить новый узел. Поиск данного узла осуществляется с помощью простого цикла for по половине списка (в
  зависимости от значения индекса — либо с начала до элемента, либо с конца до элемента). Далее создается узел для
  нового элемента, ссылка на предыдущий элемент устанавливается на узел на позиции index-1, а ссылка на следующий
  элемент устанавливается на узел c позицией index+1. Ссылки ранее существующих узлов пока не изменены.
* Теперь последовательно заменяются ссылки: для элемента, следующего за новым элементом, заменяется ссылка на предыдущий
  элемент. Для предшествующего новому элементу заменяется ссылка на следующий элемент.
* И в последнюю очередь увеличивается размер списка.

**Удаление элемента из связного списка по значению:**

1. Сначала искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого
   узла.
2. Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной.
3. Потом переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга.
4. Затем обнуляется значение узла, который содержит удаляемый объект, а также уменьшается размер коллекции.

В заключение отмечу, что как и ArrayList, LinkedList не синхронизирован. Если требуется потокобезопасность, можно
использовать Collections.synchronizedList.**

**Выводы**

* Каждый элемент содержит ссылки на предыдущий и следующий элементы
* **Не синхронизирован;**
* позволяет хранить любые объекты, в том числе null и повторяющиеся;
* **Быстрая вставка и удаление первого**, последнего и элемента из середины списка за константное время O(1). Не
  учитывая время поиска позиции элемента, который осуществляется за линейное
  время O(n);
* Долгое время поиска позиции элемента за линейное время O(n)

```java
public class LinkedList<E>
        extends AbstractSequentialList<E>
        implements List<E>, Deque<E>, Cloneable, Serializable
```

У LinkedList есть методы для работы с началом и концом списка, которых нет в ArrayList:

1. addFirst() - Вставляет элемент в начало списка.
2. addLast() - Вставляет элемент в конец списка.
3. removeFirst() - Удаляет и возвращает первый элемент из этого списка.
4. removeLast() - Удаляет и возвращает последний элемент из этого списка.

**НО**! Все элементы массива **ArrayList** находятся в одном блоке памяти, и операция по сдвигу элементов массива
выполняются
быстрым низкоуровневым методом System.arraycopy()
Обычно весь внутренний массив попадает в кэш процессора, поэтому элементы массива сдвигаются даже не в памяти, а в кэше.
Все это делает использование LinkedList не частым случаем.