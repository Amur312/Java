1.Приведите примеры полиморфизма при наследовании.

2. Что такое апкастинг и что такое даункастинг?
3. Объясните применение оператора instanceof.
4. Приведите пример использования полиморфизма для раз-
   деления интерфейса и реализации.
5. Обсудите возможность проектирования классов из диаграм-
   мы на рис. 4.2 (с. 90) в соответствии с принципом замещения
   Лисков (см. гл. 8).
6. Единичное и множественное наследование – разъясните
   возможность реализации в Java.

**Что такое «полиморфизм»?**

Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того
же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается
на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта
производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним
будет производиться по ссылке родительского типа).

1. Примеры полиморфизма при наследовании:

* При наследовании класса от другого класса, когда объекты первого класса могут использовать все методы и свойства
  объектов второго класса.
* При использовании интерфейса, когда объект может реализовывать несколько интерфейсов и использовать все методы,
  определенные в этих интерфейсах.
* При использовании множественного наследования, когда один и тот же класс может наследоваться от нескольких базовых
  классов.

2. Что такое апкастинг и что такое даункастинг?

    * Апкастинг (Upcasting):
      Апкастинг происходит, когда объект преобразуется в тип, который находится выше в иерархии наследования.
      Например,
      если у вас есть иерархия классов Vehicle и Car, и Car наследует от Vehicle, то объект типа Car может быть
      преобразован в тип Vehicle.
      В Java апкастинг является неявным преобразованием и может быть выполнен автоматически во время выполнения без
      явного указания типа.
        ```java
        class Vehicle { }
        class Car extends Vehicle { }
          
        Car car = new Car();
        Vehicle vehicle = car; // Апкастинг - преобразование типа Car в тип Vehicle
        ```
    * Даункастинг (Downcasting):
      Даункастинг происходит, когда объект преобразуется обратно в тип, который находится ниже по иерархии
      наследования. Это преобразование требует явного указания типа (приведение типов) и может привести к
      ошибке
      времени выполнения, если объект не совместим с указанным типом.
      В Java даункастинг требует явного приведения типов с помощью оператора (Type).
        ```java
            class Vehicle { }
            class Car extends Vehicle { }
        
            Vehicle vehicle = new Car();
            Car car = (Car) vehicle; // Даункастинг - приведение типа Vehicle к типу Car
       ```
      Важно помнить, что если объект не является экземпляром класса, к которому он приводится с помощью
      даункастинга, будет выброшено исключение ClassCastException. Поэтому перед выполнением даункастинга
      рекомендуется проверять, является ли объект экземпляром нужного класса с помощью оператора instanceof.

3. Объясните применение оператора instanceof.

   Оператор instanceof используется для проверки, является ли объектом указанным классом или интерфейсом. Если объект
   является указанным классом или реализует указанный интерфейс, оператор возвращает true, иначе — false.

   **Пример использования оператора instanceof:**
    ```java
    String str = "Hello, world!";

    if (str instanceof String) {
    System.out.println("str is an instance of String class.");
    }

В данном примере объект str является экземпляром класса String, поэтому оператор instanceof возвращает true.

4. Приведите пример использования полиморфизма для раз-
   деления интерфейса и реализации.
   ```java
      // Интерфейс
   interface Shape { 
     void draw();
   }
   
   // Классы, реализующие интерфейс Shape
   class Rectangle implements Shape {
      @Override
      public void draw() {
      System.out.println("Рисование прямоугольника");
      }
   }
   
   class Square implements Shape {
      @Override
      public void draw() {
      System.out.println("Рисование квадрата");
      }
   }
   
   // Метод, принимающий объекты классов, реализующих интерфейс Shape
   void drawShape(Shape shape) {
      shape.draw();
   }
   
   // Пример использования метода drawShape()
   drawShape(new Rectangle()); // Рисование прямоугольника
   drawShape(new Square()); // Рисование квадрата
   ```
   В данном примере мы определяем интерфейс Shape, который описывает общий метод draw(). Затем мы определяем два класса,
   Rectangle и Square, которые реализуют интерфейс Shape. Метод drawShape() принимает объекты классов, реализующих
   интерфейс Shape, и вызывает метод draw() для каждого объекта.

В этом примере мы используем полиморфизм, чтобы разделить интерфейс и его реализацию, что позволяет нам изменять
реализацию метода draw() без изменения интерфейса.

6. Единичное и множественное наследование – разъясните
   возможность реализации в Java.

Единичное наследование в Java означает, что класс может наследовать только один другой класс. Это ограничение привносит
иерархическую структуру в коде, что помогает упростить его понимание и поддержку.

Пример единичного наследования в Java:

```java
class Animal {
    void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog is barking");
    }
}
```

Здесь класс Dog наследует класс Animal. Это единичное наследование, так как класс Dog расширяет только один класс -
Animal.

Множественное наследование в Java подразумевает возможность класса наследовать свойства и методы от нескольких классов.
Однако, в Java множественное наследование непосредственно через классы не поддерживается из-за проблемы "алмазного
наследования" (diamond problem), когда один и тот же метод или свойство может быть унаследовано от нескольких предков,
что может привести к неоднозначности и сложностям в разрешении.

Вместо множественного наследования классы в Java могут использовать интерфейсы для реализации подобного поведения.
Интерфейс в Java определяет набор методов, которые класс должен реализовать. Класс может реализовать несколько
интерфейсов, что позволяет ему использовать методы из всех этих интерфейсов.

Пример использования интерфейсов вместо множественного наследования:

```java
interface Animal {
    void eat();
}

interface Pet {
    void play();
}

class Dog implements Animal, Pet {
    public void eat() {
        System.out.println("Dog is eating");
    }

    public void play() {
        System.out.println("Dog is playing");
    }
}
```

Здесь класс Dog реализует интерфейсы Animal и Pet, что позволяет ему наследовать поведение обоих интерфейсов. Таким
образом, Java обходит проблему множественного наследования, используя интерфейсы для описания совокупности методов,
которые класс должен реализовать.